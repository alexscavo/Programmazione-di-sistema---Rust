{"$message_type":"diagnostic","message":"unused import: `log::debug`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":39,"byte_end":49,"line_start":2,"line_end":2,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"use log::debug;","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":35,"byte_end":50,"line_start":2,"line_end":2,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"use log::debug;","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `log::debug`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtests\\complex_numbers.rs:2:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse log::debug;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0284","explanation":"This error occurs when the compiler is unable to unambiguously infer the\nreturn type of a function or method which is generic on return type, such\nas the `collect` method for `Iterator`s.\n\nFor example:\n\n```compile_fail,E0284\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    d = d + n.into();\n}\n```\n\nHere we have an addition of `d` and `n.into()`. Hence, `n.into()` can return\nany type `T` where `u64: Add<T>`. On the other hand, the `into` method can\nreturn any type where `u32: Into<T>`.\n\nThe author of this code probably wants `into()` to return a `u64`, but the\ncompiler can't be sure that there isn't another type `T` where both\n`u32: Into<T>` and `u64: Add<T>`.\n\nTo resolve this error, use a concrete type for the intermediate expression:\n\n```\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    let m: u64 = n.into();\n    d = d + m;\n}\n```\n"},"level":"error","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":3365,"byte_end":3373,"line_start":140,"line_end":140,"column_start":19,"column_end":27,"is_primary":false,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":19,"highlight_end":27}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"tests\\complex_numbers.rs","byte_start":3377,"byte_end":3380,"line_start":140,"line_end":140,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":31,"highlight_end":34}],"label":"cannot infer type of the type parameter `T` declared on the enum `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `<ComplexNumber as TryInto<_>>::Error == &str`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the generic arguments","code":null,"level":"help","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":3380,"byte_end":3380,"line_start":140,"line_end":140,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"::<T, &str>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0284]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtests\\complex_numbers.rs:140:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    assert_eq!(n2.try_into(), Err(\"Errore\"));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type of the type parameter `T` declared on the enum `Result`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: cannot satisfy `<ComplexNumber as TryInto<_>>::Error == &str`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider specifying the generic arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    assert_eq!(n2.try_into(), Err\u001b[0m\u001b[0m\u001b[38;5;10m::<T, &str>\u001b[0m\u001b[0m(\"Errore\"));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":3365,"byte_end":3373,"line_start":140,"line_end":140,"column_start":19,"column_end":27,"is_primary":false,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":19,"highlight_end":27}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"tests\\complex_numbers.rs","byte_start":3377,"byte_end":3380,"line_start":140,"line_end":140,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":31,"highlight_end":34}],"label":"cannot infer type of the type parameter `T` declared on the enum `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `ComplexNumber: TryInto<_>` found in the following crates: `core`, `es2`:\n- impl TryInto<f64> for ComplexNumber;\n- impl<T, U> TryInto<U> for T\n  where U: TryFrom<T>;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the generic arguments","code":null,"level":"help","spans":[{"file_name":"tests\\complex_numbers.rs","byte_start":3380,"byte_end":3380,"line_start":140,"line_end":140,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"    assert_eq!(n2.try_into(), Err(\"Errore\"));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"::<T, &str>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtests\\complex_numbers.rs:140:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    assert_eq!(n2.try_into(), Err(\"Errore\"));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type of the type parameter `T` declared on the enum `Result`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: multiple `impl`s satisfying `ComplexNumber: TryInto<_>` found in the following crates: `core`, `es2`:\u001b[0m\n\u001b[0m            - impl TryInto<f64> for ComplexNumber;\u001b[0m\n\u001b[0m            - impl<T, U> TryInto<U> for T\u001b[0m\n\u001b[0m              where U: TryFrom<T>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider specifying the generic arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    assert_eq!(n2.try_into(), Err\u001b[0m\u001b[0m\u001b[38;5;10m::<T, &str>\u001b[0m\u001b[0m(\"Errore\"));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 2 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 2 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0283, E0284.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0283, E0284.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0283`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0283`.\u001b[0m\n"}
